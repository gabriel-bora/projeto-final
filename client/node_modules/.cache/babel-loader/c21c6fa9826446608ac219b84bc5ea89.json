{"ast":null,"code":"'use strict';\n\nvar assert = require('assert').ok;\nvar zlib = require('zlib');\nvar util = require('util');\nvar kMaxLength = require('buffer').kMaxLength;\nfunction Inflate(opts) {\n  if (!(this instanceof Inflate)) {\n    return new Inflate(opts);\n  }\n  if (opts && opts.chunkSize < zlib.Z_MIN_CHUNK) {\n    opts.chunkSize = zlib.Z_MIN_CHUNK;\n  }\n  zlib.Inflate.call(this, opts);\n\n  // Node 8 --> 9 compatibility check\n  this._offset = this._offset === undefined ? this._outOffset : this._offset;\n  this._buffer = this._buffer || this._outBuffer;\n  if (opts && opts.maxLength != null) {\n    this._maxLength = opts.maxLength;\n  }\n}\nfunction createInflate(opts) {\n  return new Inflate(opts);\n}\nfunction _close(engine, callback) {\n  if (callback) {\n    process.nextTick(callback);\n  }\n\n  // Caller may invoke .close after a zlib error (which will null _handle).\n  if (!engine._handle) {\n    return;\n  }\n  engine._handle.close();\n  engine._handle = null;\n}\nInflate.prototype._processChunk = function (chunk, flushFlag, asyncCb) {\n  if (typeof asyncCb === 'function') {\n    return zlib.Inflate._processChunk.call(this, chunk, flushFlag, asyncCb);\n  }\n  var self = this;\n  var availInBefore = chunk && chunk.length;\n  var availOutBefore = this._chunkSize - this._offset;\n  var leftToInflate = this._maxLength;\n  var inOff = 0;\n  var buffers = [];\n  var nread = 0;\n  var error;\n  this.on('error', function (err) {\n    error = err;\n  });\n  function handleChunk(availInAfter, availOutAfter) {\n    if (self._hadError) {\n      return;\n    }\n    var have = availOutBefore - availOutAfter;\n    assert(have >= 0, 'have should not go down');\n    if (have > 0) {\n      var out = self._buffer.slice(self._offset, self._offset + have);\n      self._offset += have;\n      if (out.length > leftToInflate) {\n        out = out.slice(0, leftToInflate);\n      }\n      buffers.push(out);\n      nread += out.length;\n      leftToInflate -= out.length;\n      if (leftToInflate === 0) {\n        return false;\n      }\n    }\n    if (availOutAfter === 0 || self._offset >= self._chunkSize) {\n      availOutBefore = self._chunkSize;\n      self._offset = 0;\n      self._buffer = Buffer.allocUnsafe(self._chunkSize);\n    }\n    if (availOutAfter === 0) {\n      inOff += availInBefore - availInAfter;\n      availInBefore = availInAfter;\n      return true;\n    }\n    return false;\n  }\n  assert(this._handle, 'zlib binding closed');\n  do {\n    var res = this._handle.writeSync(flushFlag, chunk,\n    // in\n    inOff,\n    // in_off\n    availInBefore,\n    // in_len\n    this._buffer,\n    // out\n    this._offset,\n    //out_off\n    availOutBefore); // out_len\n    // Node 8 --> 9 compatibility check\n    res = res || this._writeState;\n  } while (!this._hadError && handleChunk(res[0], res[1]));\n  if (this._hadError) {\n    throw error;\n  }\n  if (nread >= kMaxLength) {\n    _close(this);\n    throw new RangeError('Cannot create final Buffer. It would be larger than 0x' + kMaxLength.toString(16) + ' bytes');\n  }\n  var buf = Buffer.concat(buffers, nread);\n  _close(this);\n  return buf;\n};\nutil.inherits(Inflate, zlib.Inflate);\nfunction zlibBufferSync(engine, buffer) {\n  if (typeof buffer === 'string') {\n    buffer = Buffer.from(buffer);\n  }\n  if (!(buffer instanceof Buffer)) {\n    throw new TypeError('Not a string or buffer');\n  }\n  var flushFlag = engine._finishFlushFlag;\n  if (flushFlag == null) {\n    flushFlag = zlib.Z_FINISH;\n  }\n  return engine._processChunk(buffer, flushFlag);\n}\nfunction inflateSync(buffer, opts) {\n  return zlibBufferSync(new Inflate(opts), buffer);\n}\nmodule.exports = exports = inflateSync;\nexports.Inflate = Inflate;\nexports.createInflate = createInflate;\nexports.inflateSync = inflateSync;","map":{"version":3,"names":["assert","require","ok","zlib","util","kMaxLength","Inflate","opts","chunkSize","Z_MIN_CHUNK","call","_offset","undefined","_outOffset","_buffer","_outBuffer","maxLength","_maxLength","createInflate","_close","engine","callback","process","nextTick","_handle","close","prototype","_processChunk","chunk","flushFlag","asyncCb","self","availInBefore","length","availOutBefore","_chunkSize","leftToInflate","inOff","buffers","nread","error","on","err","handleChunk","availInAfter","availOutAfter","_hadError","have","out","slice","push","Buffer","allocUnsafe","res","writeSync","_writeState","RangeError","toString","buf","concat","inherits","zlibBufferSync","buffer","from","TypeError","_finishFlushFlag","Z_FINISH","inflateSync","module","exports"],"sources":["D:/Documents/QQTech/projeto-final/client/node_modules/pngjs/lib/sync-inflate.js"],"sourcesContent":["'use strict';\n\nvar assert = require('assert').ok;\nvar zlib = require('zlib');\nvar util = require('util');\n\nvar kMaxLength = require('buffer').kMaxLength;\n\nfunction Inflate(opts) {\n  if (!(this instanceof Inflate)) {\n    return new Inflate(opts);\n  }\n\n  if (opts && opts.chunkSize < zlib.Z_MIN_CHUNK) {\n    opts.chunkSize = zlib.Z_MIN_CHUNK;\n  }\n\n  zlib.Inflate.call(this, opts);\n\n  // Node 8 --> 9 compatibility check\n  this._offset = this._offset === undefined ? this._outOffset : this._offset;\n  this._buffer = this._buffer || this._outBuffer;\n\n  if (opts && opts.maxLength != null) {\n    this._maxLength = opts.maxLength;\n  }\n}\n\nfunction createInflate(opts) {\n  return new Inflate(opts);\n}\n\nfunction _close(engine, callback) {\n  if (callback) {\n    process.nextTick(callback);\n  }\n\n  // Caller may invoke .close after a zlib error (which will null _handle).\n  if (!engine._handle) {\n    return;\n  }\n\n  engine._handle.close();\n  engine._handle = null;\n}\n\nInflate.prototype._processChunk = function(chunk, flushFlag, asyncCb) {\n  if (typeof asyncCb === 'function') {\n    return zlib.Inflate._processChunk.call(this, chunk, flushFlag, asyncCb);\n  }\n\n  var self = this;\n\n  var availInBefore = chunk && chunk.length;\n  var availOutBefore = this._chunkSize - this._offset;\n  var leftToInflate = this._maxLength;\n  var inOff = 0;\n\n  var buffers = [];\n  var nread = 0;\n\n  var error;\n  this.on('error', function(err) {\n    error = err;\n  });\n\n  function handleChunk(availInAfter, availOutAfter) {\n    if (self._hadError) {\n      return;\n    }\n\n    var have = availOutBefore - availOutAfter;\n    assert(have >= 0, 'have should not go down');\n\n    if (have > 0) {\n      var out = self._buffer.slice(self._offset, self._offset + have);\n      self._offset += have;\n\n      if (out.length > leftToInflate) {\n        out = out.slice(0, leftToInflate);\n      }\n\n      buffers.push(out);\n      nread += out.length;\n      leftToInflate -= out.length;\n\n      if (leftToInflate === 0) {\n        return false;\n      }\n    }\n\n    if (availOutAfter === 0 || self._offset >= self._chunkSize) {\n      availOutBefore = self._chunkSize;\n      self._offset = 0;\n      self._buffer = Buffer.allocUnsafe(self._chunkSize);\n    }\n\n    if (availOutAfter === 0) {\n      inOff += (availInBefore - availInAfter);\n      availInBefore = availInAfter;\n\n      return true;\n    }\n\n    return false;\n  }\n\n  assert(this._handle, 'zlib binding closed');\n  do {\n    var res = this._handle.writeSync(flushFlag,\n      chunk, // in\n      inOff, // in_off\n      availInBefore, // in_len\n      this._buffer, // out\n      this._offset, //out_off\n      availOutBefore); // out_len\n    // Node 8 --> 9 compatibility check\n    res = res || this._writeState;\n  } while (!this._hadError && handleChunk(res[0], res[1]));\n\n  if (this._hadError) {\n    throw error;\n  }\n\n  if (nread >= kMaxLength) {\n    _close(this);\n    throw new RangeError('Cannot create final Buffer. It would be larger than 0x' + kMaxLength.toString(16) + ' bytes');\n  }\n\n  var buf = Buffer.concat(buffers, nread);\n  _close(this);\n\n  return buf;\n};\n\nutil.inherits(Inflate, zlib.Inflate);\n\nfunction zlibBufferSync(engine, buffer) {\n  if (typeof buffer === 'string') {\n    buffer = Buffer.from(buffer);\n  }\n  if (!(buffer instanceof Buffer)) {\n    throw new TypeError('Not a string or buffer');\n  }\n\n  var flushFlag = engine._finishFlushFlag;\n  if (flushFlag == null) {\n    flushFlag = zlib.Z_FINISH;\n  }\n\n  return engine._processChunk(buffer, flushFlag);\n}\n\nfunction inflateSync(buffer, opts) {\n  return zlibBufferSync(new Inflate(opts), buffer);\n}\n\nmodule.exports = exports = inflateSync;\nexports.Inflate = Inflate;\nexports.createInflate = createInflate;\nexports.inflateSync = inflateSync;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}