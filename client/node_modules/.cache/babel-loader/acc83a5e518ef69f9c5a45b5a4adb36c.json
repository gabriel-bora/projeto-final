{"ast":null,"code":"/** vim: et:ts=4:sw=4:sts=4\n * @license amdefine 0.1.0 Copyright (c) 2011, The Dojo Foundation All Rights Reserved.\n * Available via the MIT or new BSD license.\n * see: http://github.com/jrburke/amdefine for details\n */\n\n/*jslint node: true */\n/*global module, process */\n'use strict';\n\n/**\n * Creates a define for node.\n * @param {Object} module the \"module\" object that is defined by Node for the\n * current module.\n * @param {Function} [requireFn]. Node's require function for the current module.\n * It only needs to be passed in Node versions before 0.5, when module.require\n * did not exist.\n * @returns {Function} a define function that is usable for the current node\n * module.\n */\nfunction amdefine(module, requireFn) {\n  'use strict';\n\n  var defineCache = {},\n    loaderCache = {},\n    alreadyCalled = false,\n    path = require('path'),\n    makeRequire,\n    stringRequire;\n\n  /**\n   * Trims the . and .. from an array of path segments.\n   * It will keep a leading path segment if a .. will become\n   * the first path segment, to help with module name lookups,\n   * which act like paths, but can be remapped. But the end result,\n   * all paths that use this function should look normalized.\n   * NOTE: this method MODIFIES the input array.\n   * @param {Array} ary the array of path segments.\n   */\n  function trimDots(ary) {\n    var i, part;\n    for (i = 0; ary[i]; i += 1) {\n      part = ary[i];\n      if (part === '.') {\n        ary.splice(i, 1);\n        i -= 1;\n      } else if (part === '..') {\n        if (i === 1 && (ary[2] === '..' || ary[0] === '..')) {\n          //End of the line. Keep at least one non-dot\n          //path segment at the front so it can be mapped\n          //correctly to disk. Otherwise, there is likely\n          //no path mapping for a path starting with '..'.\n          //This can still fail, but catches the most reasonable\n          //uses of ..\n          break;\n        } else if (i > 0) {\n          ary.splice(i - 1, 2);\n          i -= 2;\n        }\n      }\n    }\n  }\n  function normalize(name, baseName) {\n    var baseParts;\n\n    //Adjust any relative paths.\n    if (name && name.charAt(0) === '.') {\n      //If have a base name, try to normalize against it,\n      //otherwise, assume it is a top-level require that will\n      //be relative to baseUrl in the end.\n      if (baseName) {\n        baseParts = baseName.split('/');\n        baseParts = baseParts.slice(0, baseParts.length - 1);\n        baseParts = baseParts.concat(name.split('/'));\n        trimDots(baseParts);\n        name = baseParts.join('/');\n      }\n    }\n    return name;\n  }\n\n  /**\n   * Create the normalize() function passed to a loader plugin's\n   * normalize method.\n   */\n  function makeNormalize(relName) {\n    return function (name) {\n      return normalize(name, relName);\n    };\n  }\n  function makeLoad(id) {\n    function load(value) {\n      loaderCache[id] = value;\n    }\n    load.fromText = function (id, text) {\n      //This one is difficult because the text can/probably uses\n      //define, and any relative paths and requires should be relative\n      //to that id was it would be found on disk. But this would require\n      //bootstrapping a module/require fairly deeply from node core.\n      //Not sure how best to go about that yet.\n      throw new Error('amdefine does not implement load.fromText');\n    };\n    return load;\n  }\n  makeRequire = function (systemRequire, exports, module, relId) {\n    function amdRequire(deps, callback) {\n      if (typeof deps === 'string') {\n        //Synchronous, single module require('')\n        return stringRequire(systemRequire, exports, module, deps, relId);\n      } else {\n        //Array of dependencies with a callback.\n\n        //Convert the dependencies to modules.\n        deps = deps.map(function (depName) {\n          return stringRequire(systemRequire, exports, module, depName, relId);\n        });\n\n        //Wait for next tick to call back the require call.\n        if (callback) {\n          process.nextTick(function () {\n            callback.apply(null, deps);\n          });\n        }\n      }\n    }\n    amdRequire.toUrl = function (filePath) {\n      if (filePath.indexOf('.') === 0) {\n        return normalize(filePath, path.dirname(module.filename));\n      } else {\n        return filePath;\n      }\n    };\n    return amdRequire;\n  };\n\n  //Favor explicit value, passed in if the module wants to support Node 0.4.\n  requireFn = requireFn || function req() {\n    return module.require.apply(module, arguments);\n  };\n  function runFactory(id, deps, factory) {\n    var r, e, m, result;\n    if (id) {\n      e = loaderCache[id] = {};\n      m = {\n        id: id,\n        uri: __filename,\n        exports: e\n      };\n      r = makeRequire(requireFn, e, m, id);\n    } else {\n      //Only support one define call per file\n      if (alreadyCalled) {\n        throw new Error('amdefine with no module ID cannot be called more than once per file.');\n      }\n      alreadyCalled = true;\n\n      //Use the real variables from node\n      //Use module.exports for exports, since\n      //the exports in here is amdefine exports.\n      e = module.exports;\n      m = module;\n      r = makeRequire(requireFn, e, m, module.id);\n    }\n\n    //If there are dependencies, they are strings, so need\n    //to convert them to dependency values.\n    if (deps) {\n      deps = deps.map(function (depName) {\n        return r(depName);\n      });\n    }\n\n    //Call the factory with the right dependencies.\n    if (typeof factory === 'function') {\n      result = factory.apply(m.exports, deps);\n    } else {\n      result = factory;\n    }\n    if (result !== undefined) {\n      m.exports = result;\n      if (id) {\n        loaderCache[id] = m.exports;\n      }\n    }\n  }\n  stringRequire = function (systemRequire, exports, module, id, relId) {\n    //Split the ID by a ! so that\n    var index = id.indexOf('!'),\n      originalId = id,\n      prefix,\n      plugin;\n    if (index === -1) {\n      id = normalize(id, relId);\n\n      //Straight module lookup. If it is one of the special dependencies,\n      //deal with it, otherwise, delegate to node.\n      if (id === 'require') {\n        return makeRequire(systemRequire, exports, module, relId);\n      } else if (id === 'exports') {\n        return exports;\n      } else if (id === 'module') {\n        return module;\n      } else if (loaderCache.hasOwnProperty(id)) {\n        return loaderCache[id];\n      } else if (defineCache[id]) {\n        runFactory.apply(null, defineCache[id]);\n        return loaderCache[id];\n      } else {\n        if (systemRequire) {\n          return systemRequire(originalId);\n        } else {\n          throw new Error('No module with ID: ' + id);\n        }\n      }\n    } else {\n      //There is a plugin in play.\n      prefix = id.substring(0, index);\n      id = id.substring(index + 1, id.length);\n      plugin = stringRequire(systemRequire, exports, module, prefix, relId);\n      if (plugin.normalize) {\n        id = plugin.normalize(id, makeNormalize(relId));\n      } else {\n        //Normalize the ID normally.\n        id = normalize(id, relId);\n      }\n      if (loaderCache[id]) {\n        return loaderCache[id];\n      } else {\n        plugin.load(id, makeRequire(systemRequire, exports, module, relId), makeLoad(id), {});\n        return loaderCache[id];\n      }\n    }\n  };\n\n  //Create a define function specific to the module asking for amdefine.\n  function define(id, deps, factory) {\n    if (Array.isArray(id)) {\n      factory = deps;\n      deps = id;\n      id = undefined;\n    } else if (typeof id !== 'string') {\n      factory = id;\n      id = deps = undefined;\n    }\n    if (deps && !Array.isArray(deps)) {\n      factory = deps;\n      deps = undefined;\n    }\n    if (!deps) {\n      deps = ['require', 'exports', 'module'];\n    }\n\n    //Set up properties for this module. If an ID, then use\n    //internal cache. If no ID, then use the external variables\n    //for this node module.\n    if (id) {\n      //Put the module in deep freeze until there is a\n      //require call for it.\n      defineCache[id] = [id, deps, factory];\n    } else {\n      runFactory(id, deps, factory);\n    }\n  }\n\n  //define.require, which has access to all the values in the\n  //cache. Useful for AMD modules that all have IDs in the file,\n  //but need to finally export a value to node based on one of those\n  //IDs.\n  define.require = function (id) {\n    if (loaderCache[id]) {\n      return loaderCache[id];\n    }\n    if (defineCache[id]) {\n      runFactory.apply(null, defineCache[id]);\n      return loaderCache[id];\n    }\n  };\n  define.amd = {};\n  return define;\n}\nmodule.exports = amdefine;","map":{"version":3,"names":["amdefine","module","requireFn","defineCache","loaderCache","alreadyCalled","path","require","makeRequire","stringRequire","trimDots","ary","i","part","splice","normalize","name","baseName","baseParts","charAt","split","slice","length","concat","join","makeNormalize","relName","makeLoad","id","load","value","fromText","text","Error","systemRequire","exports","relId","amdRequire","deps","callback","map","depName","process","nextTick","apply","toUrl","filePath","indexOf","dirname","filename","req","arguments","runFactory","factory","r","e","m","result","uri","__filename","undefined","index","originalId","prefix","plugin","hasOwnProperty","substring","define","Array","isArray","amd"],"sources":["D:/Documents/QQTech/projeto-final/client/node_modules/amdefine/amdefine.js"],"sourcesContent":["/** vim: et:ts=4:sw=4:sts=4\n * @license amdefine 0.1.0 Copyright (c) 2011, The Dojo Foundation All Rights Reserved.\n * Available via the MIT or new BSD license.\n * see: http://github.com/jrburke/amdefine for details\n */\n\n/*jslint node: true */\n/*global module, process */\n'use strict';\n\n/**\n * Creates a define for node.\n * @param {Object} module the \"module\" object that is defined by Node for the\n * current module.\n * @param {Function} [requireFn]. Node's require function for the current module.\n * It only needs to be passed in Node versions before 0.5, when module.require\n * did not exist.\n * @returns {Function} a define function that is usable for the current node\n * module.\n */\nfunction amdefine(module, requireFn) {\n    'use strict';\n    var defineCache = {},\n        loaderCache = {},\n        alreadyCalled = false,\n        path = require('path'),\n        makeRequire, stringRequire;\n\n    /**\n     * Trims the . and .. from an array of path segments.\n     * It will keep a leading path segment if a .. will become\n     * the first path segment, to help with module name lookups,\n     * which act like paths, but can be remapped. But the end result,\n     * all paths that use this function should look normalized.\n     * NOTE: this method MODIFIES the input array.\n     * @param {Array} ary the array of path segments.\n     */\n    function trimDots(ary) {\n        var i, part;\n        for (i = 0; ary[i]; i+= 1) {\n            part = ary[i];\n            if (part === '.') {\n                ary.splice(i, 1);\n                i -= 1;\n            } else if (part === '..') {\n                if (i === 1 && (ary[2] === '..' || ary[0] === '..')) {\n                    //End of the line. Keep at least one non-dot\n                    //path segment at the front so it can be mapped\n                    //correctly to disk. Otherwise, there is likely\n                    //no path mapping for a path starting with '..'.\n                    //This can still fail, but catches the most reasonable\n                    //uses of ..\n                    break;\n                } else if (i > 0) {\n                    ary.splice(i - 1, 2);\n                    i -= 2;\n                }\n            }\n        }\n    }\n\n    function normalize(name, baseName) {\n        var baseParts;\n\n        //Adjust any relative paths.\n        if (name && name.charAt(0) === '.') {\n            //If have a base name, try to normalize against it,\n            //otherwise, assume it is a top-level require that will\n            //be relative to baseUrl in the end.\n            if (baseName) {\n                baseParts = baseName.split('/');\n                baseParts = baseParts.slice(0, baseParts.length - 1);\n                baseParts = baseParts.concat(name.split('/'));\n                trimDots(baseParts);\n                name = baseParts.join('/');\n            }\n        }\n\n        return name;\n    }\n\n    /**\n     * Create the normalize() function passed to a loader plugin's\n     * normalize method.\n     */\n    function makeNormalize(relName) {\n        return function (name) {\n            return normalize(name, relName);\n        };\n    }\n\n    function makeLoad(id) {\n        function load(value) {\n            loaderCache[id] = value;\n        }\n\n        load.fromText = function (id, text) {\n            //This one is difficult because the text can/probably uses\n            //define, and any relative paths and requires should be relative\n            //to that id was it would be found on disk. But this would require\n            //bootstrapping a module/require fairly deeply from node core.\n            //Not sure how best to go about that yet.\n            throw new Error('amdefine does not implement load.fromText');\n        };\n\n        return load;\n    }\n\n    makeRequire = function (systemRequire, exports, module, relId) {\n        function amdRequire(deps, callback) {\n            if (typeof deps === 'string') {\n                //Synchronous, single module require('')\n                return stringRequire(systemRequire, exports, module, deps, relId);\n            } else {\n                //Array of dependencies with a callback.\n\n                //Convert the dependencies to modules.\n                deps = deps.map(function (depName) {\n                    return stringRequire(systemRequire, exports, module, depName, relId);\n                });\n\n                //Wait for next tick to call back the require call.\n                if (callback) {\n                    process.nextTick(function () {\n                        callback.apply(null, deps);\n                    });\n                }\n            }\n        }\n\n        amdRequire.toUrl = function (filePath) {\n            if (filePath.indexOf('.') === 0) {\n                return normalize(filePath, path.dirname(module.filename));\n            } else {\n                return filePath;\n            }\n        };\n\n        return amdRequire;\n    };\n\n    //Favor explicit value, passed in if the module wants to support Node 0.4.\n    requireFn = requireFn || function req() {\n        return module.require.apply(module, arguments);\n    };\n\n    function runFactory(id, deps, factory) {\n        var r, e, m, result;\n\n        if (id) {\n            e = loaderCache[id] = {};\n            m = {\n                id: id,\n                uri: __filename,\n                exports: e\n            };\n            r = makeRequire(requireFn, e, m, id);\n        } else {\n            //Only support one define call per file\n            if (alreadyCalled) {\n                throw new Error('amdefine with no module ID cannot be called more than once per file.');\n            }\n            alreadyCalled = true;\n\n            //Use the real variables from node\n            //Use module.exports for exports, since\n            //the exports in here is amdefine exports.\n            e = module.exports;\n            m = module;\n            r = makeRequire(requireFn, e, m, module.id);\n        }\n\n        //If there are dependencies, they are strings, so need\n        //to convert them to dependency values.\n        if (deps) {\n            deps = deps.map(function (depName) {\n                return r(depName);\n            });\n        }\n\n        //Call the factory with the right dependencies.\n        if (typeof factory === 'function') {\n            result = factory.apply(m.exports, deps);\n        } else {\n            result = factory;\n        }\n\n        if (result !== undefined) {\n            m.exports = result;\n            if (id) {\n                loaderCache[id] = m.exports;\n            }\n        }\n    }\n\n    stringRequire = function (systemRequire, exports, module, id, relId) {\n        //Split the ID by a ! so that\n        var index = id.indexOf('!'),\n            originalId = id,\n            prefix, plugin;\n\n        if (index === -1) {\n            id = normalize(id, relId);\n\n            //Straight module lookup. If it is one of the special dependencies,\n            //deal with it, otherwise, delegate to node.\n            if (id === 'require') {\n                return makeRequire(systemRequire, exports, module, relId);\n            } else if (id === 'exports') {\n                return exports;\n            } else if (id === 'module') {\n                return module;\n            } else if (loaderCache.hasOwnProperty(id)) {\n                return loaderCache[id];\n            } else if (defineCache[id]) {\n                runFactory.apply(null, defineCache[id]);\n                return loaderCache[id];\n            } else {\n                if(systemRequire) {\n                    return systemRequire(originalId);\n                } else {\n                    throw new Error('No module with ID: ' + id);\n                }\n            }\n        } else {\n            //There is a plugin in play.\n            prefix = id.substring(0, index);\n            id = id.substring(index + 1, id.length);\n\n            plugin = stringRequire(systemRequire, exports, module, prefix, relId);\n\n            if (plugin.normalize) {\n                id = plugin.normalize(id, makeNormalize(relId));\n            } else {\n                //Normalize the ID normally.\n                id = normalize(id, relId);\n            }\n\n            if (loaderCache[id]) {\n                return loaderCache[id];\n            } else {\n                plugin.load(id, makeRequire(systemRequire, exports, module, relId), makeLoad(id), {});\n\n                return loaderCache[id];\n            }\n        }\n    };\n\n    //Create a define function specific to the module asking for amdefine.\n    function define(id, deps, factory) {\n        if (Array.isArray(id)) {\n            factory = deps;\n            deps = id;\n            id = undefined;\n        } else if (typeof id !== 'string') {\n            factory = id;\n            id = deps = undefined;\n        }\n\n        if (deps && !Array.isArray(deps)) {\n            factory = deps;\n            deps = undefined;\n        }\n\n        if (!deps) {\n            deps = ['require', 'exports', 'module'];\n        }\n\n        //Set up properties for this module. If an ID, then use\n        //internal cache. If no ID, then use the external variables\n        //for this node module.\n        if (id) {\n            //Put the module in deep freeze until there is a\n            //require call for it.\n            defineCache[id] = [id, deps, factory];\n        } else {\n            runFactory(id, deps, factory);\n        }\n    }\n\n    //define.require, which has access to all the values in the\n    //cache. Useful for AMD modules that all have IDs in the file,\n    //but need to finally export a value to node based on one of those\n    //IDs.\n    define.require = function (id) {\n        if (loaderCache[id]) {\n            return loaderCache[id];\n        }\n\n        if (defineCache[id]) {\n            runFactory.apply(null, defineCache[id]);\n            return loaderCache[id];\n        }\n    };\n\n    define.amd = {};\n\n    return define;\n}\n\nmodule.exports = amdefine;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,QAAQ,CAACC,MAAM,EAAEC,SAAS,EAAE;EACjC,YAAY;;EACZ,IAAIC,WAAW,GAAG,CAAC,CAAC;IAChBC,WAAW,GAAG,CAAC,CAAC;IAChBC,aAAa,GAAG,KAAK;IACrBC,IAAI,GAAGC,OAAO,CAAC,MAAM,CAAC;IACtBC,WAAW;IAAEC,aAAa;;EAE9B;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,SAASC,QAAQ,CAACC,GAAG,EAAE;IACnB,IAAIC,CAAC,EAAEC,IAAI;IACX,KAAKD,CAAC,GAAG,CAAC,EAAED,GAAG,CAACC,CAAC,CAAC,EAAEA,CAAC,IAAG,CAAC,EAAE;MACvBC,IAAI,GAAGF,GAAG,CAACC,CAAC,CAAC;MACb,IAAIC,IAAI,KAAK,GAAG,EAAE;QACdF,GAAG,CAACG,MAAM,CAACF,CAAC,EAAE,CAAC,CAAC;QAChBA,CAAC,IAAI,CAAC;MACV,CAAC,MAAM,IAAIC,IAAI,KAAK,IAAI,EAAE;QACtB,IAAID,CAAC,KAAK,CAAC,KAAKD,GAAG,CAAC,CAAC,CAAC,KAAK,IAAI,IAAIA,GAAG,CAAC,CAAC,CAAC,KAAK,IAAI,CAAC,EAAE;UACjD;UACA;UACA;UACA;UACA;UACA;UACA;QACJ,CAAC,MAAM,IAAIC,CAAC,GAAG,CAAC,EAAE;UACdD,GAAG,CAACG,MAAM,CAACF,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;UACpBA,CAAC,IAAI,CAAC;QACV;MACJ;IACJ;EACJ;EAEA,SAASG,SAAS,CAACC,IAAI,EAAEC,QAAQ,EAAE;IAC/B,IAAIC,SAAS;;IAEb;IACA,IAAIF,IAAI,IAAIA,IAAI,CAACG,MAAM,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;MAChC;MACA;MACA;MACA,IAAIF,QAAQ,EAAE;QACVC,SAAS,GAAGD,QAAQ,CAACG,KAAK,CAAC,GAAG,CAAC;QAC/BF,SAAS,GAAGA,SAAS,CAACG,KAAK,CAAC,CAAC,EAAEH,SAAS,CAACI,MAAM,GAAG,CAAC,CAAC;QACpDJ,SAAS,GAAGA,SAAS,CAACK,MAAM,CAACP,IAAI,CAACI,KAAK,CAAC,GAAG,CAAC,CAAC;QAC7CV,QAAQ,CAACQ,SAAS,CAAC;QACnBF,IAAI,GAAGE,SAAS,CAACM,IAAI,CAAC,GAAG,CAAC;MAC9B;IACJ;IAEA,OAAOR,IAAI;EACf;;EAEA;AACJ;AACA;AACA;EACI,SAASS,aAAa,CAACC,OAAO,EAAE;IAC5B,OAAO,UAAUV,IAAI,EAAE;MACnB,OAAOD,SAAS,CAACC,IAAI,EAAEU,OAAO,CAAC;IACnC,CAAC;EACL;EAEA,SAASC,QAAQ,CAACC,EAAE,EAAE;IAClB,SAASC,IAAI,CAACC,KAAK,EAAE;MACjB1B,WAAW,CAACwB,EAAE,CAAC,GAAGE,KAAK;IAC3B;IAEAD,IAAI,CAACE,QAAQ,GAAG,UAAUH,EAAE,EAAEI,IAAI,EAAE;MAChC;MACA;MACA;MACA;MACA;MACA,MAAM,IAAIC,KAAK,CAAC,2CAA2C,CAAC;IAChE,CAAC;IAED,OAAOJ,IAAI;EACf;EAEArB,WAAW,GAAG,UAAU0B,aAAa,EAAEC,OAAO,EAAElC,MAAM,EAAEmC,KAAK,EAAE;IAC3D,SAASC,UAAU,CAACC,IAAI,EAAEC,QAAQ,EAAE;MAChC,IAAI,OAAOD,IAAI,KAAK,QAAQ,EAAE;QAC1B;QACA,OAAO7B,aAAa,CAACyB,aAAa,EAAEC,OAAO,EAAElC,MAAM,EAAEqC,IAAI,EAAEF,KAAK,CAAC;MACrE,CAAC,MAAM;QACH;;QAEA;QACAE,IAAI,GAAGA,IAAI,CAACE,GAAG,CAAC,UAAUC,OAAO,EAAE;UAC/B,OAAOhC,aAAa,CAACyB,aAAa,EAAEC,OAAO,EAAElC,MAAM,EAAEwC,OAAO,EAAEL,KAAK,CAAC;QACxE,CAAC,CAAC;;QAEF;QACA,IAAIG,QAAQ,EAAE;UACVG,OAAO,CAACC,QAAQ,CAAC,YAAY;YACzBJ,QAAQ,CAACK,KAAK,CAAC,IAAI,EAAEN,IAAI,CAAC;UAC9B,CAAC,CAAC;QACN;MACJ;IACJ;IAEAD,UAAU,CAACQ,KAAK,GAAG,UAAUC,QAAQ,EAAE;MACnC,IAAIA,QAAQ,CAACC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE;QAC7B,OAAOhC,SAAS,CAAC+B,QAAQ,EAAExC,IAAI,CAAC0C,OAAO,CAAC/C,MAAM,CAACgD,QAAQ,CAAC,CAAC;MAC7D,CAAC,MAAM;QACH,OAAOH,QAAQ;MACnB;IACJ,CAAC;IAED,OAAOT,UAAU;EACrB,CAAC;;EAED;EACAnC,SAAS,GAAGA,SAAS,IAAI,SAASgD,GAAG,GAAG;IACpC,OAAOjD,MAAM,CAACM,OAAO,CAACqC,KAAK,CAAC3C,MAAM,EAAEkD,SAAS,CAAC;EAClD,CAAC;EAED,SAASC,UAAU,CAACxB,EAAE,EAAEU,IAAI,EAAEe,OAAO,EAAE;IACnC,IAAIC,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEC,MAAM;IAEnB,IAAI7B,EAAE,EAAE;MACJ2B,CAAC,GAAGnD,WAAW,CAACwB,EAAE,CAAC,GAAG,CAAC,CAAC;MACxB4B,CAAC,GAAG;QACA5B,EAAE,EAAEA,EAAE;QACN8B,GAAG,EAAEC,UAAU;QACfxB,OAAO,EAAEoB;MACb,CAAC;MACDD,CAAC,GAAG9C,WAAW,CAACN,SAAS,EAAEqD,CAAC,EAAEC,CAAC,EAAE5B,EAAE,CAAC;IACxC,CAAC,MAAM;MACH;MACA,IAAIvB,aAAa,EAAE;QACf,MAAM,IAAI4B,KAAK,CAAC,sEAAsE,CAAC;MAC3F;MACA5B,aAAa,GAAG,IAAI;;MAEpB;MACA;MACA;MACAkD,CAAC,GAAGtD,MAAM,CAACkC,OAAO;MAClBqB,CAAC,GAAGvD,MAAM;MACVqD,CAAC,GAAG9C,WAAW,CAACN,SAAS,EAAEqD,CAAC,EAAEC,CAAC,EAAEvD,MAAM,CAAC2B,EAAE,CAAC;IAC/C;;IAEA;IACA;IACA,IAAIU,IAAI,EAAE;MACNA,IAAI,GAAGA,IAAI,CAACE,GAAG,CAAC,UAAUC,OAAO,EAAE;QAC/B,OAAOa,CAAC,CAACb,OAAO,CAAC;MACrB,CAAC,CAAC;IACN;;IAEA;IACA,IAAI,OAAOY,OAAO,KAAK,UAAU,EAAE;MAC/BI,MAAM,GAAGJ,OAAO,CAACT,KAAK,CAACY,CAAC,CAACrB,OAAO,EAAEG,IAAI,CAAC;IAC3C,CAAC,MAAM;MACHmB,MAAM,GAAGJ,OAAO;IACpB;IAEA,IAAII,MAAM,KAAKG,SAAS,EAAE;MACtBJ,CAAC,CAACrB,OAAO,GAAGsB,MAAM;MAClB,IAAI7B,EAAE,EAAE;QACJxB,WAAW,CAACwB,EAAE,CAAC,GAAG4B,CAAC,CAACrB,OAAO;MAC/B;IACJ;EACJ;EAEA1B,aAAa,GAAG,UAAUyB,aAAa,EAAEC,OAAO,EAAElC,MAAM,EAAE2B,EAAE,EAAEQ,KAAK,EAAE;IACjE;IACA,IAAIyB,KAAK,GAAGjC,EAAE,CAACmB,OAAO,CAAC,GAAG,CAAC;MACvBe,UAAU,GAAGlC,EAAE;MACfmC,MAAM;MAAEC,MAAM;IAElB,IAAIH,KAAK,KAAK,CAAC,CAAC,EAAE;MACdjC,EAAE,GAAGb,SAAS,CAACa,EAAE,EAAEQ,KAAK,CAAC;;MAEzB;MACA;MACA,IAAIR,EAAE,KAAK,SAAS,EAAE;QAClB,OAAOpB,WAAW,CAAC0B,aAAa,EAAEC,OAAO,EAAElC,MAAM,EAAEmC,KAAK,CAAC;MAC7D,CAAC,MAAM,IAAIR,EAAE,KAAK,SAAS,EAAE;QACzB,OAAOO,OAAO;MAClB,CAAC,MAAM,IAAIP,EAAE,KAAK,QAAQ,EAAE;QACxB,OAAO3B,MAAM;MACjB,CAAC,MAAM,IAAIG,WAAW,CAAC6D,cAAc,CAACrC,EAAE,CAAC,EAAE;QACvC,OAAOxB,WAAW,CAACwB,EAAE,CAAC;MAC1B,CAAC,MAAM,IAAIzB,WAAW,CAACyB,EAAE,CAAC,EAAE;QACxBwB,UAAU,CAACR,KAAK,CAAC,IAAI,EAAEzC,WAAW,CAACyB,EAAE,CAAC,CAAC;QACvC,OAAOxB,WAAW,CAACwB,EAAE,CAAC;MAC1B,CAAC,MAAM;QACH,IAAGM,aAAa,EAAE;UACd,OAAOA,aAAa,CAAC4B,UAAU,CAAC;QACpC,CAAC,MAAM;UACH,MAAM,IAAI7B,KAAK,CAAC,qBAAqB,GAAGL,EAAE,CAAC;QAC/C;MACJ;IACJ,CAAC,MAAM;MACH;MACAmC,MAAM,GAAGnC,EAAE,CAACsC,SAAS,CAAC,CAAC,EAAEL,KAAK,CAAC;MAC/BjC,EAAE,GAAGA,EAAE,CAACsC,SAAS,CAACL,KAAK,GAAG,CAAC,EAAEjC,EAAE,CAACN,MAAM,CAAC;MAEvC0C,MAAM,GAAGvD,aAAa,CAACyB,aAAa,EAAEC,OAAO,EAAElC,MAAM,EAAE8D,MAAM,EAAE3B,KAAK,CAAC;MAErE,IAAI4B,MAAM,CAACjD,SAAS,EAAE;QAClBa,EAAE,GAAGoC,MAAM,CAACjD,SAAS,CAACa,EAAE,EAAEH,aAAa,CAACW,KAAK,CAAC,CAAC;MACnD,CAAC,MAAM;QACH;QACAR,EAAE,GAAGb,SAAS,CAACa,EAAE,EAAEQ,KAAK,CAAC;MAC7B;MAEA,IAAIhC,WAAW,CAACwB,EAAE,CAAC,EAAE;QACjB,OAAOxB,WAAW,CAACwB,EAAE,CAAC;MAC1B,CAAC,MAAM;QACHoC,MAAM,CAACnC,IAAI,CAACD,EAAE,EAAEpB,WAAW,CAAC0B,aAAa,EAAEC,OAAO,EAAElC,MAAM,EAAEmC,KAAK,CAAC,EAAET,QAAQ,CAACC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;QAErF,OAAOxB,WAAW,CAACwB,EAAE,CAAC;MAC1B;IACJ;EACJ,CAAC;;EAED;EACA,SAASuC,MAAM,CAACvC,EAAE,EAAEU,IAAI,EAAEe,OAAO,EAAE;IAC/B,IAAIe,KAAK,CAACC,OAAO,CAACzC,EAAE,CAAC,EAAE;MACnByB,OAAO,GAAGf,IAAI;MACdA,IAAI,GAAGV,EAAE;MACTA,EAAE,GAAGgC,SAAS;IAClB,CAAC,MAAM,IAAI,OAAOhC,EAAE,KAAK,QAAQ,EAAE;MAC/ByB,OAAO,GAAGzB,EAAE;MACZA,EAAE,GAAGU,IAAI,GAAGsB,SAAS;IACzB;IAEA,IAAItB,IAAI,IAAI,CAAC8B,KAAK,CAACC,OAAO,CAAC/B,IAAI,CAAC,EAAE;MAC9Be,OAAO,GAAGf,IAAI;MACdA,IAAI,GAAGsB,SAAS;IACpB;IAEA,IAAI,CAACtB,IAAI,EAAE;MACPA,IAAI,GAAG,CAAC,SAAS,EAAE,SAAS,EAAE,QAAQ,CAAC;IAC3C;;IAEA;IACA;IACA;IACA,IAAIV,EAAE,EAAE;MACJ;MACA;MACAzB,WAAW,CAACyB,EAAE,CAAC,GAAG,CAACA,EAAE,EAAEU,IAAI,EAAEe,OAAO,CAAC;IACzC,CAAC,MAAM;MACHD,UAAU,CAACxB,EAAE,EAAEU,IAAI,EAAEe,OAAO,CAAC;IACjC;EACJ;;EAEA;EACA;EACA;EACA;EACAc,MAAM,CAAC5D,OAAO,GAAG,UAAUqB,EAAE,EAAE;IAC3B,IAAIxB,WAAW,CAACwB,EAAE,CAAC,EAAE;MACjB,OAAOxB,WAAW,CAACwB,EAAE,CAAC;IAC1B;IAEA,IAAIzB,WAAW,CAACyB,EAAE,CAAC,EAAE;MACjBwB,UAAU,CAACR,KAAK,CAAC,IAAI,EAAEzC,WAAW,CAACyB,EAAE,CAAC,CAAC;MACvC,OAAOxB,WAAW,CAACwB,EAAE,CAAC;IAC1B;EACJ,CAAC;EAEDuC,MAAM,CAACG,GAAG,GAAG,CAAC,CAAC;EAEf,OAAOH,MAAM;AACjB;AAEAlE,MAAM,CAACkC,OAAO,GAAGnC,QAAQ"},"metadata":{},"sourceType":"script"}