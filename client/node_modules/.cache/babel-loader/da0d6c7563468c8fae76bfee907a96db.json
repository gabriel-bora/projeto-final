{"ast":null,"code":"const {\n  PNG\n} = require('pngjs');\nconst {\n  getShasumData\n} = require('./encryption');\nconst {\n  isRgbByte\n} = require('./png');\nconst {\n  BYTE_SIZE,\n  LENGTH_BYTES,\n  SHASUM_BYTES\n} = require('./defaults');\nconst extractBinary = b => b % 2;\nconst splitBitsAsBytes = bitsAsBytes => (_, i) => {\n  const start = i * BYTE_SIZE;\n  return bitsAsBytes.slice(start, start + BYTE_SIZE);\n};\nconst combineByteIntoBit = (accumulator, currentByte, i) => {\n  const shiftDistance = BYTE_SIZE - 1 - i;\n  return currentByte << shiftDistance | accumulator;\n};\nconst combineBufferIntoByte = buffer => buffer.reduce(combineByteIntoBit, 0);\nconst combineBits = bitsAsBytes => {\n  const n = Math.ceil(bitsAsBytes.length / BYTE_SIZE);\n  return Array(n).fill(null).map(splitBitsAsBytes(bitsAsBytes)).map(combineBufferIntoByte);\n};\nconst decode = data => {\n  const bitsAsBytes = data.map(extractBinary);\n  const combined = combineBits(bitsAsBytes);\n  return Buffer.from(combined);\n};\nconst messageMatchesShasum = (message, shasum) => getShasumData(message).equals(shasum);\nconst extractData = imageData => {\n  const rgb = imageData.filter(isRgbByte);\n  const lengthDataSize = LENGTH_BYTES * BYTE_SIZE;\n  const shasumDataSize = SHASUM_BYTES * BYTE_SIZE;\n  const lengthAndShasumSize = lengthDataSize + shasumDataSize;\n  const lengthData = rgb.slice(0, lengthDataSize);\n  const decodedLengthData = decode(lengthData);\n  const length = parseInt(decodedLengthData.toString('hex'), 16) * BYTE_SIZE;\n  const shasumData = rgb.slice(lengthDataSize, lengthAndShasumSize);\n  const decodedShasumData = decode(shasumData);\n  const messageData = rgb.slice(lengthAndShasumSize, lengthAndShasumSize + length);\n  const decodedMessageData = decode(messageData);\n  if (!messageMatchesShasum(decodedMessageData, decodedShasumData)) throw new Error('Shasum did not match decoded message');\n  return decodedMessageData;\n};\nconst reveal = (image, encoding) => {\n  const png = PNG.sync.read(image);\n  const data = extractData(png.data);\n  return encoding ? data.toString(encoding) : data;\n};\nmodule.exports = {\n  reveal\n};","map":{"version":3,"names":["PNG","require","getShasumData","isRgbByte","BYTE_SIZE","LENGTH_BYTES","SHASUM_BYTES","extractBinary","b","splitBitsAsBytes","bitsAsBytes","_","i","start","slice","combineByteIntoBit","accumulator","currentByte","shiftDistance","combineBufferIntoByte","buffer","reduce","combineBits","n","Math","ceil","length","Array","fill","map","decode","data","combined","Buffer","from","messageMatchesShasum","message","shasum","equals","extractData","imageData","rgb","filter","lengthDataSize","shasumDataSize","lengthAndShasumSize","lengthData","decodedLengthData","parseInt","toString","shasumData","decodedShasumData","messageData","decodedMessageData","Error","reveal","image","encoding","png","sync","read","module","exports"],"sources":["D:/Documents/QQTech/projeto-final/client/node_modules/steggy-noencrypt/lib/reveal.js"],"sourcesContent":["const { PNG } = require('pngjs')\nconst { getShasumData } = require('./encryption')\nconst { isRgbByte } = require('./png')\nconst {\n  BYTE_SIZE,\n  LENGTH_BYTES,\n  SHASUM_BYTES,\n} = require('./defaults')\n\nconst extractBinary = b => b % 2\n\nconst splitBitsAsBytes = bitsAsBytes => (_, i) => {\n  const start = i * BYTE_SIZE\n  return bitsAsBytes.slice(start, start + BYTE_SIZE)\n}\n\nconst combineByteIntoBit = (accumulator, currentByte, i) => {\n  const shiftDistance = (BYTE_SIZE - 1) - i\n  return (currentByte << shiftDistance) | accumulator\n}\n\nconst combineBufferIntoByte = buffer =>\n  buffer.reduce(combineByteIntoBit, 0)\n\nconst combineBits = bitsAsBytes => {\n  const n = Math.ceil(bitsAsBytes.length / BYTE_SIZE)\n  return Array(n)\n    .fill(null)\n    .map(splitBitsAsBytes(bitsAsBytes))\n    .map(combineBufferIntoByte)\n}\n\nconst decode = data => {\n  const bitsAsBytes = data.map(extractBinary)\n  const combined = combineBits(bitsAsBytes)\n  return Buffer.from(combined)\n}\n\nconst messageMatchesShasum = (message, shasum) =>\n  getShasumData(message).equals(shasum)\n\nconst extractData = imageData => {\n  const rgb = imageData.filter(isRgbByte)\n\n  const lengthDataSize = LENGTH_BYTES * BYTE_SIZE\n  const shasumDataSize = SHASUM_BYTES * BYTE_SIZE\n  const lengthAndShasumSize = lengthDataSize + shasumDataSize\n\n  const lengthData = rgb.slice(0, lengthDataSize)\n  const decodedLengthData = decode(lengthData)\n  const length = parseInt(decodedLengthData.toString('hex'), 16) * BYTE_SIZE\n\n  const shasumData = rgb.slice(lengthDataSize, lengthAndShasumSize)\n  const decodedShasumData = decode(shasumData)\n\n  const messageData = rgb.slice(lengthAndShasumSize, lengthAndShasumSize + length)\n  const decodedMessageData = decode(messageData)\n\n  if (!messageMatchesShasum(decodedMessageData, decodedShasumData))\n    throw new Error('Shasum did not match decoded message')\n\n  return decodedMessageData\n}\n\nconst reveal = (image, encoding) => {\n  const png = PNG.sync.read(image)\n  const data = extractData(png.data)\n\n  return encoding\n    ? data.toString(encoding)\n    : data\n}\n\nmodule.exports = {\n  reveal,\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}